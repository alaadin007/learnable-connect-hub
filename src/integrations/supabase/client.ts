
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://ldlgckwkdsvrfuymidrr.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxkbGdja3drZHN2cmZ1eW1pZHJyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYwNTc2NzksImV4cCI6MjA2MTYzMzY3OX0.kItrTMcKThMXuwNDClYNTGkEq-1EVVldq1vFw7ZsKx0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      flowType: 'pkce', // Use PKCE flow for more security but better compatibility
      debug: process.env.NODE_ENV === 'development', // Enable debug mode in development
    },
    global: {
      // Set reasonable timeouts for fetches
      fetch: (url, options) => {
        const timeout = 30000; // 30 seconds (increased from 20)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        
        return fetch(url, {
          ...options,
          signal: controller.signal,
          headers: {
            ...options?.headers,
            'X-Client-Info': 'learning-platform-web-app', // Add client identifier for better tracking
          },
        })
        .then(response => {
          clearTimeout(timeoutId);
          return response;
        })
        .catch(error => {
          clearTimeout(timeoutId);
          console.error('Supabase fetch error:', error);
          throw error;
        });
      }
    }
  }
);

// Add error handling for supabase operations
supabase.auth.onAuthStateChange((event, session) => {
  if (event === 'SIGNED_OUT') {
    console.log('User signed out');
    // Clear any local session data
    localStorage.removeItem('lastActiveRole');
    localStorage.removeItem('lastActiveSchool');
  } else if (event === 'SIGNED_IN') {
    console.log('User signed in');
  } else if (event === 'TOKEN_REFRESHED') {
    console.log('Token refreshed');
  } else if (event === 'USER_UPDATED') {
    console.log('User updated');
  }
});

// Enhanced helper function to detect test accounts
export const isTestAccount = (email: string | null | undefined): boolean => {
  // Used to identify development test accounts which get special handling
  if (!email) return false;
  
  // Check email domains and patterns
  return email.endsWith('@testschool.edu') || 
         email.endsWith('.test@learnable.edu') || 
         email.includes('test') || 
         email.includes('demo') ||
         email === 'school.test@learnable.edu' ||
         email === 'teacher.test@learnable.edu' ||
         email === 'student.test@learnable.edu';
};

// Check if a school or user ID is a test entity
export const isTestEntity = (id: string | null | undefined): boolean => {
  if (!id) return false;
  return id.startsWith('test-') || id.includes('test');
};

// Default test school code - used when creating test accounts
export const TEST_SCHOOL_CODE = 'TESTCODE';

// Helper for type safety with RPC functions
export type TeacherInvitationResult = {
  invitation_id: string;
  school_id: string;
  school_name: string;
  email: string;
}

// Function to validate user role access
export const validateRoleAccess = async (userId: string | undefined, requiredRole: string | string[] | undefined): Promise<boolean> => {
  if (!userId || !requiredRole) return false;
  
  try {
    // Get user profile to check role
    const { data: profile, error } = await supabase
      .from('profiles')
      .select('user_type')
      .eq('id', userId)
      .single();
    
    if (error || !profile) return false;
    
    // Check if user has required role
    if (Array.isArray(requiredRole)) {
      return requiredRole.includes(profile.user_type);
    } else {
      return profile.user_type === requiredRole;
    }
  } catch (error) {
    console.error('Error validating role access:', error);
    return false;
  }
};
